=============================================================
NAME:VISHAL CHANDRAKANT GADADE
DIV:A
ENROLL NO:2200776
ROLL NO:2371046

============================================================
                        	 Practical 1
=============================================================

1.	Generate a 2D plot for the following function using the Python.

(i)	y = sinx, 0 ≤ x ≤ 2π
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 2*np.pi, 1000)  # For 1000 points between 0 and 2*pi
y = np.sin(x)

plt.figure(figsize=(8, 6))
plt.plot(x, y, color='blue', label='y = sin(x)')
plt.title('Plot of y = sin(x)')
plt.xlabel('x')
plt.ylabel('y')
plt.grid(True)
plt.legend()
plt.show()

----------------------------------------------------------------------------
(ii)	y = e−0.4x sinx, 0 ≤ x ≤ 4π
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 4*np.pi, 1000)  # For 1000 points between 0 and 4*pi
y = np.exp(-0.4 * x) * np.sin(x)

plt.figure(figsize=(8, 6))
plt.plot(x, y, color='red', label='y = e^(-0.4x) * sin(x)')
plt.title('Plot of y = e^(-0.4x) * sin(x)')
plt.xlabel('x')
plt.ylabel('y')
plt.grid(True)
plt.legend()
plt.show()

-----------------------------------------------------------------
(iii)
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-5, 5, 1000) 
y = np.sin(x) / (1 + x**2)

plt.figure(figsize=(8, 6))
plt.plot(x, y, color='green', label='y = sin(x) / (1 + x^2)')
plt.title('Plot of y = sin(x) / (1 + x^2)')
plt.xlabel('x')
plt.ylabel('y')
plt.grid(True)
plt.legend()
plt.show()

========================================================================
2.	Generate subplots for the following functions using the Python.
(i)	y = sinx , y = cosx , − 2π ≤ x ≤ 2π(2 × 1 subplots)
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-2*np.pi, 2*np.pi, 1000)
y_sin = np.sin(x)
y_cos = np.cos(x)

fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(8, 6))

axes[0].plot(x, y_sin, color='blue', label='y = sin(x)')
axes[0].set_title('Plot of y = sin(x)')
axes[0].set_xlabel('x')
axes[0].set_ylabel('y = sin(x)')
axes[0].grid(True)
axes[0].legend()

axes[1].plot(x, y_cos, color='red', label='y = cos(x)')
axes[1].set_title('Plot of y = cos(x)')
axes[1].set_xlabel('x')
axes[1].set_ylabel('y = cos(x)')
axes[1].grid(True)
axes[1].legend()

plt.tight_layout()
plt.show()

------------------------------------------------------------------
(ii)	y = e−x sinx , y = e−2x cosx , 0 ≤ x ≤ 4π(2 × 1 subplots)

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 4*np.pi, 1000)
y1 = np.exp(-x) * np.sin(x)
y2 = np.exp(-2*x) * np.cos(x)

fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(8, 10))

axes[0].plot(x, y1, color='blue', label='y = e^(-x) * sin(x)')
axes[0].set_title('Plot of y = e^(-x) * sin(x)')
axes[0].set_xlabel('x')
axes[0].set_ylabel('y = e^(-x) * sin(x)')
axes[0].grid(True)
axes[0].legend()

axes[1].plot(x, y2, color='red', label='y = e^(-2x) * cos(x)')
axes[1].set_title('Plot of y = e^(-2x) * cos(x)')
axes[1].set_xlabel('x')
axes[1].set_ylabel('y = e^(-2x) * cos(x)')
axes[1].grid(True)
axes[1].legend()

plt.tight_layout()
plt.show()

-------------------------------------------------------------------
(iii)	y = x , y = x2 , y = x3, y = x4 − 5 ≤ x ≤ 5(2 × 2 subplots)
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-5, 5, 1000)
y1 = x
y2 = x**2
y3 = x**3
y4 = x**4

fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(10, 8))

axes[0, 0].plot(x, y1, color='blue', label='y = x')
axes[0, 0].set_title('Plot of y = x')
axes[0, 0].set_xlabel('x')
axes[0, 0].set_ylabel('y = x')
axes[0, 0].grid(True)
axes[0, 0].legend()

axes[0, 1].plot(x, y2, color='red', label='y = x^2')
axes[0, 1].set_title('Plot of y = x^2')
axes[0, 1].set_xlabel('x')
axes[0, 1].set_ylabel('y = x^2')
axes[0, 1].grid(True)
axes[0, 1].legend()

axes[1, 0].plot(x, y3, color='green', label='y = x^3')
axes[1, 0].set_title('Plot of y = x^3')
axes[1, 0].set_xlabel('x')
axes[1, 0].set_ylabel('y = x^3')
axes[1, 0].grid(True)
axes[1, 0].legend()

axes[1, 1].plot(x, y4, color='orange', label='y = x^4')
axes[1, 1].set_title('Plot of y = x^4')
axes[1, 1].set_xlabel('x')
axes[1, 1].set_ylabel('y = x^4')
axes[1, 1].grid(True)
axes[1, 1].legend()

plt.tight_layout()
plt.show()

=======================================================================================
                         Practical 2
=======================================================================================

1.	Generate 3D contour Plots for the following function:

(i)	f(x,y) = sin(x + y) for x ∈ [−2π,2π],y ∈ [−2π,2pi]
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = np.linspace(-2*np.pi, 2*np.pi, 100)
y = np.linspace(-2*np.pi, 2*np.pi, 100)

X, Y = np.meshgrid(x, y)
Z = np.sin(X + Y)

fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
contour = ax.contour3D(X, Y, Z, 50, cmap='viridis')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(X, Y) = sin(X + Y)')
ax.set_title('3D Contour Plot of f(X, Y) = sin(X + Y)')
fig.colorbar(contour, ax=ax, shrink=0.5, aspect=5)
plt.show()

---------------------------------------------------------------

(ii)	f(x,y) = x3 + y2 for x ∈ [0,2π],y ∈ [0,2pi]
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = np.linspace(0, 2*np.pi, 100)
y = np.linspace(0, 2*np.pi, 100)

X, Y = np.meshgrid(x, y)
Z = X**3 + Y**2

fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
contour = ax.contour3D(X, Y, Z, 50, cmap='viridis')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(X, Y) = X^3 + Y^2')
ax.set_title('3D Contour Plot of f(X, Y) = X^3 + Y^2')
fig.colorbar(contour, ax=ax, shrink=0.5, aspect=5)
plt.show()
---------------------------------------------------------------------

(iii)	f(x,y) = sin(x) + cos(y) for x ∈ [−2π,2π],y ∈ [−2π,2pi]
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = np.linspace(-2*np.pi, 2*np.pi, 100)
y = np.linspace(-2*np.pi, 2*np.pi, 100)

X, Y = np.meshgrid(x, y)
Z = np.sin(X) + np.cos(Y)

fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
contour = ax.contour3D(X, Y, Z, 50, cmap='viridis')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(X, Y) = sin(X) + cos(Y)')
ax.set_title('3D Contour Plot of f(X, Y) = sin(X) + cos(Y)')
fig.colorbar(contour, ax=ax, shrink=0.5, aspect=5)
plt.show()
==============================================================================================

2.	Generate 3D wireframe Plots for the following function: f(x,y) = ex2+y2 for x ∈ [0,2π] , y ∈ [0,2π]
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = np.linspace(0, 2*np.pi, 100)
y = np.linspace(0, 2*np.pi, 100)

X, Y = np.meshgrid(x, y)
Z = np.exp(X**2 + Y**2)

fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
wireframe = ax.plot_wireframe(X, Y, Z, color='blue')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(X, Y) = exp(X^2 + Y^2)')
ax.set_title('3D Wireframe Plot of f(X, Y) = exp(X^2 + Y^2)')
plt.show()
===============================================================================================

3.	Generate 3D surface plots for the following function: f(x,y) = x3+y3+x2+y2+x+y+5 for x ∈ [−2,2], y ∈ [−2,2].
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = np.linspace(-2, 2, 100)
y = np.linspace(-2, 2, 100)

X, Y = np.meshgrid(x, y)
Z = X**3 + Y**3 + X**2 + Y**2 + X + Y + 5

fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
surface = ax.plot_surface(X, Y, Z, cmap='viridis')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('f(X, Y) = X^3 + Y^3 + X^2 + Y^2 + X + Y + 5')
ax.set_title('3D Surface Plot of f(X, Y) = X^3 + Y^3 + X^2 + Y^2 + X + Y + 5')
fig.colorbar(surface, ax=ax, shrink=0.5, aspect=5)
plt.show()


=======================================================================================
                         Practical 3 & 4
=======================================================================================
1. Represent the following points using Point(x,y) command.
x = (12, −9), y = (−4, 3), z = (6, 7), w = (−3, 6, 19), p = (3, 4, −17), q = (0, 0, 0)
ANS:
from sympy.geometry import Point

x = Point(12, -9)
y = Point(-4, 3)
z = Point(6, 7)
w = Point(-3, 6, 19)
p = Point(3, 4, -17)
q = Point(0, 0, 0)

print("Point x:", x)
print("Point y:", y)
print("Point z:", z)
print("Point w:", w)
print("Point p:", p)
print("Point q:", q)
OUTPUT:
Point x: Point2D(12, -9)
Point y: Point2D(-4, 3)
Point z: Point2D(6, 7)
Point w: Point3D(-3, 6, 19)
Point p: Point3D(3, 4, -17)
Point q: Point3D(0, 0, 0)
---------------------------------------------------------------------------
3. Find distance between points mentioned in the Q.1
(a) x and z (b) y and z (c) w and p
ANS:
from sympy.geometry import Point

x = Point(12, -9)
y = Point(-4, 3)
z = Point(6, 7)
w = Point(-3, 6, 19)
p = Point(3, 4, -17)
q = Point(0, 0, 0)

distance_x_z = x.distance(z)
distance_y_z = y.distance(z)
distance_w_p = w.distance(p)

print("Distance between points x and z:", distance_x_z)
print("Distance between points y and z:", distance_y_z)
print("Distance between points w and p:", distance_w_p)
OUTPUT:
Distance between points x and z: 2*sqrt(73)
Distance between points y and z: 2*sqrt(29)
Distance between points w and p: 2*sqrt(334)
-------------------------------------------------------------------------
4. (a) Scale the point x by factor 10 and 7.5
(b) Reflect the point z-through Y -axis.
Reflect the point x-through y = x line.
(c) Reflect the point (1.5, 3.6) through the line x − 2y = 1.
(d) Shear th point z = (6, 7) in y−direction by 7 units and x-direction by −3 
units.
(e) Rotate the following points by angles 45◦
, 30◦ and 75◦
respectively.
A = (6, −6) , B = (13, −100), C = (−19, −16)
ANS:
import numpy as np

# (a) Scale the point x by factors 10 and 7.5
x = (5, -3)
scale_factor_1 = 10
scale_factor_2 = 7.5

scaled_point_1 = tuple(np.array(x) * scale_factor_1)
scaled_point_2 = tuple(np.array(x) * scale_factor_2)

print("Scaled point 1:", scaled_point_1)
print("Scaled point 2:", scaled_point_2)

# (b) Reflect the point z through Y-axis and through the line y = x
z = (6, 7)

reflected_y_axis = (-z[0], z[1])
reflected_through_line = (z[1], z[0])

print("Reflected through Y-axis:", reflected_y_axis)
print("Reflected through line y = x:", reflected_through_line)

# (c) Reflect the point (1.5, 3.6) through the line x - 2y = 1
x, y = 1.5, 3.6
x_new = (x + 2 * y) / 5
y_new = (y + x) / 5
reflected_point = (x_new, y_new)

print("Reflected point:", reflected_point)

# (d) Shear the point z = (6, 7) in y-direction by 7 units and x-direction by 
-3 units
z = (6, 7)
sheared_point = (z[0] - 3, z[1] + 7)

print("Sheared point:", sheared_point)

# (e) Rotate the points A = (6, -6), B = (13, -100), C = (-19, -16) by angles 45°, 
30°, and 75° respectively
points = [(6, -6), (13, -100), (-19, -16)]
angles = [45, 30, 75]

for point, angle in zip(points, angles):
    theta = np.radians(angle)
    rotation_matrix = np.array([[np.cos(theta), -np.sin(theta)],
                                 [np.sin(theta), np.cos(theta)]])
    rotated_point = np.dot(rotation_matrix, np.array(point))
    print(f"Rotated point by {angle}°:", tuple(rotated_point))

OUTPUT:
Scaled point 1: (50, -30)
Scaled point 2: (37.5, -22.5)
Reflected through Y-axis: (-6, 7)
Reflected through line y = x: (7, 6)
Reflected point: (1.7399999999999998, 1.02)
Sheared point: (3, 14)
Rotated point by 45°: (8.485281374238571, -2.220446049250313e-16)
Rotated point by 30°: (61.2583302491977, -80.10254037844388)
Rotated point by 75°: (10.5372513636772, -22.493695421132628)
--------------------------------------------------------------------------------------
5. If the line segment joining the points A[−2 5], B[4 3] is transformed to the line 
segment A∗B∗ by the transformation
matrix A =
[
2 2
4 −1
] , then find the midpoint and length of A∗B∗
ANS:
import numpy as np

A = np.array([-2, 5, 1])
B = np.array([4, 3, 1])
T = np.array([[2, 2, 0], [4, -1, 0], [0, 0, 1]])

A_transformed = np.dot(T, A)
B_transformed = np.dot(T, B)

midpoint = (A_transformed[:2] + B_transformed[:2]) / 2
length = np.linalg.norm(B_transformed[:2] - A_transformed[:2])

print("Midpoint of A*B*:", midpoint)
print("Length of A*B*:", length)
OUTPUT:
Midpoint of A*B*: [10.  0.]
Length of A*B*: 27.202941017470888
-------------------------------------------------------------------------
6. Reflect the line segment joining the points A[−5, 2] and B[3 − 4] through 
the line y = 2x − 1
ANS:
def reflect_point_across_line(point, line):
    x1, y1 = point
    m, c = line

    x2 = (x1 + (2 * m * (y1 - c))) / (1 + (m ** 2))
    y2 = (2 * m * x2) + (2 * c - y1)

    return (x2, y2)

def reflect_segment_across_line(point_a, point_b, line):
    reflected_a = reflect_point_across_line(point_a, line)
    reflected_b = reflect_point_across_line(point_b, line)
    return reflected_a, reflected_b

def main():
    point_a = (-5, 2)
    point_b = (3, -4)
    line = (2, -1)  # y = 2x - 1

    reflected_a, reflected_b = reflect_segment_across_line(point_a, point_b, line)
    
    print("Reflected Point A:", reflected_a)
    print("Reflected Point B:", reflected_b)

if __name__ == "__main__":
    main()
OUTPUT:
Reflected Point A: (1.4, 1.5999999999999996)
Reflected Point B: (-1.8, -5.2)
---------------------------------------------------------------------------
7. Suppose that the line segment joining the points A[−1 8], B[5 − 6] is transformed 
to the line segment A∗B∗ by the
transformation matrix [T] =
[
3 −1
5 3
]. Find slope of the transformed line segment A∗B∗
ANS:
import numpy as np

def slope(point1, point2):
    return (point2[1] - point1[1]) / (point2[0] - point1[0])

def main():
    point_a = np.array([-1, 8])
    point_b = np.array([5, -6])

    transformation_matrix = np.array([[3, -1],
                                      [5, 3]])

    transformed_point_a = np.dot(transformation_matrix, point_a)
    transformed_point_b = np.dot(transformation_matrix, point_b)

    transformed_slope = slope(transformed_point_a, transformed_point_b)

    print("Slope of Transformed Line Segment A*B:", transformed_slope)

if __name__ == "__main__":
    main()
OUTPUT:
Slope of Transformed Line Segment A*B: -0.375
---------------------------------------------------------------------------
8. If the two lines 2x + y = 0 and x − 3y = 1 are transformed using the
 transformation matrix [T] =
[
2 −3
1 −1
]
then
find the point of intersection of the transformed lines.
ANS:
import numpy as np

def find_intersection(matrix1, matrix2):
    transformed_matrix1 = np.dot(matrix1, matrix2)
    x = transformed_matrix1[0, 2] / transformed_matrix1[2, 2]
    y = transformed_matrix1[1, 2] / transformed_matrix1[2, 2]
    return x, y

def main():
    transformation_matrix = np.array([[2, -3, 0],
                                       [1, -1, 0],
                                       [0, 0, 1]])

    line1 = np.array([[2, 1, 0],
                      [1, -3, 1],
                      [0, 0, 1]])

    line2 = np.array([[1, -3, 0],
                      [0, 1, 0],
                      [0, 0, 1]])

    intersection_point = find_intersection(transformation_matrix, line1)
    print("Intersection Point of Transformed Lines:", intersection_point)

if __name__ == "__main__":
    main()
OUTPUT:
Intersection Point of Transformed Lines: (-3.0, -1.0)
--------------------------------------------------------------------------
9. If we apply shearing on the line 2x − y = 8 in x and y directions by 4 and 
6 units respectively, then find the equation
of the resulting line
ANS:
def shearing_x_direction(line_eq, shear_amount):
    m, c = line_eq
    new_c = c - m * shear_amount
    return (m, new_c)

def shearing_y_direction(line_eq, shear_amount):
    m, c = line_eq
    new_m = m + shear_amount
    return (new_m, c)

def main():
    original_line_eq = (2, -8)  # Equation of the original line: 2x - y = 8
    shear_x_amount = 4
    shear_y_amount = 6

    sheared_x_line_eq = shearing_x_direction(original_line_eq, shear_x_amount)
    sheared_y_line_eq = shearing_y_direction(sheared_x_line_eq, shear_y_amount)

    print("Equation of the resulting line after shearing in x direction:", sheared_x_line_eq)
    print("Equation of the resulting line after shearing in y direction:", sheared_y_line_eq)

if __name__ == "__main__":
    main()
OUTPUT:
Equation of the resulting line after shearing in x direction: (2, -16)
Equation of the resulting line after shearing in y direction: (8, -16)


========================================================================
                       Practical 5 & 6
========================================================================
1. If a 2 × 2 transformation matrix [T] =

[1 3
2 2]

is used to transfrorm a line L, then the equation of transformed line
is y
∗ = x
∗ − 3. Find the equation of original line
ANS:
import numpy as np

T = np.array([[1, 3],
              [2, 2]])

a, b, c, d = T[0, 0], T[0, 1], T[1, 0], T[1, 1]
det = a * d - b * c
T_inv = np.array([[d, -b],
                  [-c, a]]) / det

y_star = lambda x_star: x_star - 3

def inverse_transform(x_star):
    result = np.dot(T_inv, np.array([[x_star], [y_star(x_star)]]))
    return result[1, 0]

def original_line(x):
    return inverse_transform(x)

print("Equation of the original line:")
print("y =", original_line(0), "+ x")

OUTPUT:
Equation of the original line:
y = 0.75 + x
-------------------------------------------------------------------
2. Find the combined transformation of the line segment between the 
points A[4 1] and B[−3 0] for the following
sequence of transformations: first rotation about origin through an 
angle π
c
; followed by scaling in x coordinate by
3 units; followed by reflection through the line y = 3x + 9.
ANS:
import numpy as np

A = np.array([4, 1])
B = np.array([-3, 0])

theta = np.pi
rotation_matrix = np.array([[np.cos(theta), -np.sin(theta)],
                            [np.sin(theta), np.cos(theta)]])

scaling_matrix = np.array([[3, 0],
                           [0, 1]])

reflection_matrix = np.array([[1 - 9**2, 2 * 9],
                               [2 * 9, 1 - 9**2]]) / (1 + 9**2)

A_transformed = np.dot(reflection_matrix, np.dot(scaling_matrix, np.dot(rotation_matrix, A)))
B_transformed = np.dot(reflection_matrix, np.dot(scaling_matrix, np.dot(rotation_matrix, B)))

print("Coordinates of point A after combined transformation:", A_transformed)
print("Coordinates of point B after combined transformation:", B_transformed)

OUTPUT:
Coordinates of point A after combined transformation: [11.48780488 -1.65853659]
Coordinates of point B after combined transformation: [-8.7804878   1.97560976]
---------------------------------------------------------------------------------
3. Find the combined transformation of the 4ABC where A[2 − 3], B[1 2] and C[3 − 1] for the following sequence
of transformations:
(i) Scaling in x and y coordinates by factors −1 and 2 respectively.
(ii) Reflection through x-axis.
(iii) Rotation about the origin through an angle 270◦
.
Hint:form triangle→T=T.scale(-1,2)→take two points on x axis p,q,→ l=Line(p,q)→T=T.reflect(l)→T.rotate(angle)
angle is in radians

ANS:
import numpy as np
from sympy.geometry import Point, Line

A = Point(2, -3)
B = Point(1, 2)
C = Point(3, -1)

scale_x = -1
scale_y = 2

A_scaled = A.scale(scale_x, scale_y)
B_scaled = B.scale(scale_x, scale_y)
C_scaled = C.scale(scale_x, scale_y)

x_axis = Line(Point(0, 0), Point(1, 0))

A_reflected = A_scaled.reflect(x_axis)
B_reflected = B_scaled.reflect(x_axis)
C_reflected = C_scaled.reflect(x_axis)

angle = 270 * np.pi / 180

A_rotated = A_reflected.rotate(angle)
B_rotated = B_reflected.rotate(angle)
C_rotated = C_reflected.rotate(angle)

print("Coordinates of point A after combined transformation:", A_rotated)
print("Coordinates of point B after combined transformation:", B_rotated)
print("Coordinates of point C after combined transformation:", C_rotated)

OUTPUT:
Coordinates of point A after combined transformation: Point2D(6, 2)
Coordinates of point B after combined transformation: Point2D(-4, 1)
Coordinates of point C after combined transformation: Point2D(2, 3)

                              =======================================================================================
                       			  Practical 7 , 8 & 9
	    =======================================================================================


Q1). Draw a polygon with vertices (0, 0),(1, 0),(2, 2),(1, 4) and find its 
area and perimeter.

import matplotlib.pyplot as plt

vertices = [(0, 0), (1, 0), (2, 2), (1, 4)]
x_coords, y_coords = zip(*vertices)

plt.figure()
plt.plot(x_coords + (x_coords[0],), y_coords + (y_coords[0],), marker='o')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Polygon with Vertices (0, 0), (1, 0), (2, 2), (1, 4)')

plt.grid(True)
area = 0.5 * sum(x0*y1 - x1*y0 for ((x0, y0), (x1, y1))
                 in zip(vertices, vertices[1:] + vertices[:1]))

perimeter = sum(((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 for ((x1, y1), (x2, y2))
                in zip(vertices, vertices[1:] + vertices[:1]))

print("Area:", area)
print("Perimeter:", perimeter)

plt.show()

#output:
#Area: 4.0
#Perimeter: 9.595241580617241
============================================================

#Q2). Draw a regular polygon with 4 sides and radius 6 centered at origin
 and find its area and perimeter.

import matplotlib.pyplot as plt
import numpy as np

num_sides = 4
radius = 6
angles = np.linspace(0, 2*np.pi, num_sides, endpoint=False)
x_coords = radius * np.cos(angles)
y_coords = radius * np.sin(angles)

plt.figure()
plt.plot(x_coords, y_coords, marker='o')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Regular Polygon with 4 Sides and Radius 6')
plt.axis('equal')

area = num_sides * radius ** 2 / (4 * np.tan(np.pi / num_sides))
perimeter = num_sides * radius

print("Area:", area)
print("Perimeter:", perimeter)

plt.show()

#output:-
#Area: 36.00000000000001
#Perimeter: 24
===========================================================

Q3). Draw a regular polygon with 8 vertices and radius 2 centered at
 (−1, 2) and find its area area and perimeter.

import matplotlib.pyplot as plt
import numpy as np
num_vertices = 8
radius = 2
center = (-1, 2)
angles = np.linspace(0, 2*np.pi, num_vertices, endpoint=False)
x_coords = center[0] + radius * np.cos(angles)
y_coords = center[1] + radius * np.sin(angles)

plt.figure()
plt.plot(x_coords, y_coords, marker='o')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Regular Polygon with 8 Vertices and Radius 2')
plt.axis('equal')

area = num_vertices * radius ** 2 / (4 * np.tan(np.pi / num_vertices))
perimeter = num_vertices * radius

print("Area:", area)
print("Perimeter:", perimeter)

OUTPUT:
Area: 19.31370849898476
Perimeter: 16
=================================================================

Q4).Draw a regular polygon with 7 sides and radius 6 centered at (−2, 2)
and reflect it through line x − 2y = 5

import matplotlib.pyplot as plt
import numpy as np
num_sides = 7
radius = 6
center = (-2, 2)
angles = np.linspace(0, 2*np.pi, num_sides, endpoint=False)
x_coords = center[0] + radius * np.cos(angles)
y_coords = center[1] + radius * np.sin(angles)

plt.figure()
plt.plot(x_coords, y_coords, marker='o')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Regular Polygon with 7 Sides and Radius 6')
plt.axis('equal')

def reflection_line(x, y):
    return x - 2 * y - 5

x_coords_reflected = x_coords - 2 * (reflection_line(x_coords, y_coords))[:, None]
y_coords_reflected = y_coords - 2 * (reflection_line(x_coords, y_coords))[:, None]

plt.plot(x_coords_reflected, y_coords_reflected, marker='o', color='r')

OUTPUT:
reflection_line(-2,2)
-11
====================================================================

Q5).Draw a polygon with vertices (0, 0),(−2, 0),(5, 5),(1, −6) and rotate by 
180◦ and find internal angle at each vertex

import matplotlib.pyplot as plt
import numpy as np
vertices = [(0, 0), (-2, 0), (5, 5), (1, -6)]
vertices_rotated = [(x, -y) for x, y in vertices]

plt.figure()
plt.plot(*zip(*vertices), marker='o', label='Original Polygon')
plt.plot(*zip(*vertices_rotated), marker='o', label='Rotated Polygon')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Original and Rotated Polygon')
plt.axis('equal')

angles = []
for i in range(len(vertices)):
    p1 = np.array(vertices[i-1])
    p2 = np.array(vertices[i])
    p3 = np.array(vertices[(i+1)%len(vertices)])

    v1 = p1 - p2
    v2 = p3 - p2

    dot_product = np.dot(v1, v2)
    cross_product = np.cross(v1, v2)

    angle = np.arctan2(cross_product, dot_product)
    angles.append(np.degrees(angle))

print("Internal angles at each vertex:", angles)

plt.legend()
plt.show()

OUTPUT:
Internal angles at each vertex: [-99.46232220802563, 35.53767779197438,
 34.47921568612564, 29.445428729925595]
===================================================================

Q6).Reflect the 4ABC through the line y = −3, where A[1 1], B[2 − 3], C[−1 5].

import numpy as np

# Define function for reflecting a point through a line

def reflect_point_through_line(point, line):
    x, y = point
    m, c = line
    x_reflected = (x * (1 - m ** 2) - 2 * m * y - 2 * c * m) / (1 + m ** 2)
    y_reflected = (y * (1 - m ** 2) + 2 * m * x + 2 * c) / (1 + m ** 2)
    return np.array([x_reflected, y_reflected])

# Define triangle ABC

A = np.array([1, 1])
B = np.array([2, -3])
C = np.array([-1, 5])

# Reflect triangle ABC through the line y = -3

line = (0, -3)  # y = mx + c, where m is 0 and c is -3
reflected_A = reflect_point_through_line(A, line)
reflected_B = reflect_point_through_line(B, line)
reflected_C = reflect_point_through_line(C, line)

print("Reflected points:")
print("A':", reflected_A)
print("B':", reflected_B)
print("C':", reflected_C)

OUTPUT:
Reflected points:
A': [ 1. -5.]
B': [ 2. -9.]
C': [-1. -1.]
============================================================

Q7).Rotate the 4ABC by 90◦,where A[1 − 2], B[4 − 6], C[−1 4].

import numpy as np
# Define function for rotating a point by 90 degrees counterclockwise
def rotate_point_90_degrees(point):
    x, y = point
    x_rotated = -y
    y_rotated = x
    return np.array([x_rotated, y_rotated])

# Define triangle ABC

A = np.array([1, -2])
B = np.array([4, -6])
C = np.array([-1, 4])

# Rotate triangle ABC by 90 degrees

rotated_A = rotate_point_90_degrees(A)
rotated_B = rotate_point_90_degrees(B)
rotated_C = rotate_point_90_degrees(C)

print("Rotated points:")
print("A'':", rotated_A)
print("B'':", rotated_B)
print("C'':", rotated_C)

OUTPUT:
Rotated points:
A'': [2 1]
B'': [6 4]
C'': [-4 -1]
=============================================================

Q8).Find the area and perimeter of the 4ABC, where A[0 1], B[−5 0], C[3 − 3].

import numpy as np

# Define function to calculate distance between two points
def distance(point1, point2):
    return np.linalg.norm(point1 - point2)

# Define triangle ABC points
A = np.array([0, 1])
B = np.array([-5, 0])
C = np.array([3, -3])

# Calculate lengths of sides
AB = distance(A, B)
BC = distance(B, C)
CA = distance(C, A)

# Calculate perimeter
perimeter = AB + BC + CA

# Calculate area using Heron's formula
s = perimeter / 2
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA))

print("Perimeter:", perimeter)
print("Area:", area)

OUTPUT:
Perimeter: 18.643023258910315
Area: 11.5
==============================================================

Q9).Reflect the 4ABC through the line y = x + 3, where A[−1 0], B[2 − 1], C[1 3].

import numpy as np

# Define function for reflecting a point through a line
def reflect_point_through_line(point, line):
    x, y = point
    m, c = line
    x_reflected = (x * (1 - m ** 2) - 2 * m * y - 2 * c * m) / (1 + m ** 2)
    y_reflected = (y * (1 - m ** 2) + 2 * m * x + 2 * c) / (1 + m ** 2)
    return np.array([x_reflected, y_reflected])

# Define triangle ABC
A = np.array([-1, 0])
B = np.array([2, -1])
C = np.array([1, 3])

# Reflect triangle ABC through the line y = x + 3
line = (1, 3)  # y = mx + c, where m is 1 and c is 3
reflected_A = reflect_point_through_line(A, line)
reflected_B = reflect_point_through_line(B, line)
reflected_C = reflect_point_through_line(C, line)

print("Reflected points:")
print("A':", reflected_A)
print("B':", reflected_B)
print("C':", reflected_C)

OUTPUT:
Reflected points:
A': [-3.  2.]
B': [-2.  5.]
C': [-6.  4.]
===============================================================

Q10).Rotate the 4ABC by 270◦,where A[−1 2], B[2 − 5], C[−1 7].

import numpy as np

def rotate_point_270_degrees(point):
    x, y = point
    x_rotated = y
    y_rotated = -x
    return np.array([x_rotated, y_rotated])

A = np.array([-1, 2])
B = np.array([2, -5])
C = np.array([-1, 7])

rotated_A = rotate_point_270_degrees(A)
rotated_B = rotate_point_270_degrees(B)
rotated_C = rotate_point_270_degrees(C)

print("Rotated points:")
print("A'':", rotated_A)
print("B'':", rotated_B)
print("C'':", rotated_C)

OUTPUT:
Rotated points:
A'': [2 1]
B'': [-5 -2]
C'': [7 1]
===============================================================

Q11).Find the area and perimeter of the 4ABC,where A[0 1], B[−5 0], C[−3 3].

import numpy as np

def distance(point1, point2):
    return np.linalg.norm(point1 - point2)

A = np.array([0, 1])
B = np.array([-5, 0])
C = np.array([-3, 3])

AB = distance(A, B)
BC = distance(B, C)
CA = distance(C, A)

perimeter = AB + BC + CA

s = perimeter / 2
area = np.sqrt(s * (s - AB) * (s - BC) * (s - CA))

print("Perimeter:", perimeter)
print("Area:", area)

OUTPUT:
Perimeter: 12.310122064520764
Area: 6.500000000000002
==========================================================

Q12).Find the angle at each vertices of the 4P QR,where P[1 0], Q[2 3], R[0 − 2].

import numpy as np

def angle_between_points(point1, point2, point3):
    v1 = point1 - point2
    v2 = point3 - point2
    dot_product = np.dot(v1, v2)
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    cosine_angle = dot_product / (norm_v1 * norm_v2)
    angle_in_radians = np.arccos(cosine_angle)
    angle_in_degrees = np.degrees(angle_in_radians)
    return angle_in_degrees

P = np.array([1, 0])
Q = np.array([2, 3])
R = np.array([0, -2])

angle_P = angle_between_points(Q, P, R)
angle_Q = angle_between_points(R, Q, P)
angle_R = angle_between_points(P, R, Q)

print("Angle at P:", angle_P)
print("Angle at Q:", angle_Q)
print("Angle at R:", angle_R)

OUTPUT:
Angle at P: 171.86989764584396
Angle at Q: 3.36646066342994
Angle at R: 4.76364169072622
============================================================

	-----------------------------------------------------------------
				Practical 10
	-----------------------------------------------------------------

Q. Solve the following LPP using Python and nd optimal solution if exist:

1. 
Max Z = 150x + 75y
Subject to,
4x + 6y <= 24
5x + 3y <= 15
x >= 0; y >= 0

Ans :
from scipy.optimize import linprog
c = [-150, -75]

A = [[4, 6], [5, 3]]

b = [24, 15]

x_bounds = (0, None)
y_bounds = (0, None)

res = linprog(c, A_ub=A, b_ub=b, bounds=[x_bounds, y_bounds])

if res.success:
    print("Optimal solution:")
    print("x =", res.x[0])
    print("y =", res.x[1])
    print("Optimal value of the objective function:", -res.fun)
else:
    print("No feasible solution found.")

Output:

Optimal solution:
x = 3.0
y = 0.0
Optimal value of the objective function: 450.0
2).
 Min Z = 3:5x + 2y
Subject to,
x + y >= 5
x >= 4
y <= 2
x >= 0; y >= 0
Ans : 
from scipy.optimize import linprog

c = [3.5, 2]
A = [[1, 1], [1, 0], [0, -1]]
b = [5, 4, -2]
x_bounds = (0, None)
y_bounds = (0, 2)

res = linprog(c, A_ub=A, b_ub=b, bounds=[x_bounds, y_bounds], method='highs')

if res.success:
    print("Optimal solution:")
    print("x =", res.x[0])
    print("y =", res.x[1])
    print("Optimal value of Z =", res.fun)
else:
    print("No optimal solution found.")

Output:
Optimal solution:
x = 0.0
y = 2.0
Optimal value of Z = 4.0

3).
 Max Z = 3x + 5y + 4z
Subject to,
2x + 3y <= 8
2y + 5z <= 10
3x + 2y + 4z <= 15
x >= 0; y >= 0; z >= 0

Ans:
from scipy.optimize import linprog

c = [-3, -5, -4]

A = [[2, 3, 0],
     [0, 2, 5],
     [3, 2, 4]]

b = [8, 10, 15]

x_bounds = (0, None)
y_bounds = (0, None)
z_bounds = (0, None)

res = linprog(c, A_ub=A, b_ub=b, bounds=[x_bounds, y_bounds, z_bounds])

print("Optimal solution:", res.x)
print("Optimal value:", -res.fun)

OutPut:
Optimal solution: [2.17073171 1.2195122  1.51219512]
Optimal value: 18.65853658536585

4).
Min Z = x + 2y + z
Subject to,
x+1/2y+1/2z<=1
x + 2y + z <= 8
x >= 0; y >= 0; z >= 0

Ans:
from scipy.optimize import linprog

c = [1, 2, 1]
A = [[1/2, 1/2, 1/2], [1, 2, 1]]
b = [1, 8]
x_bounds = (0, None)
y_bounds = (0, None)
z_bounds = (0, None)

res = linprog(c, A_ub=A, b_ub=b, bounds=[x_bounds, y_bounds, z_bounds], method='highs')
print("Optimal solution:", res.x)
print("Optimal value:", res.fun)

OutPut:
Optimal solution: [0. 0. 0.]
Optimal value: 0.0

5).
Min Z = x + y
Subject to,
x >= 6
y >= 6
x + y <= 11
x >= 0; y >= 0

Ans:
from scipy.optimize import linprog

c = [1, 1]
A = [[-1, 0], [0, -1], [1, 1]]
b = [-6, -6, 11]
x_bounds = (6, None)
y_bounds = (6, None)

res = linprog(c, A_ub=A, b_ub=b, bounds=[x_bounds, y_bounds])

if res.success:
    print("Optimal solution:", res.x)
    print("Optimal value:", res.fun)
else:
    print("No feasible solution found.")

OutPut:
No feasible solution found.

6).
Max Z = x + y
Subject to,
x - y >= 1
x + y >= 2
x >= 0; y >= 0

Ans:
from scipy.optimize import linprog

c = [-1, -1]
A = [[-1, 1], [1, 1]]
b = [-1, 2]
x_bounds = (0, None)
y_bounds = (0, None)

res = linprog(c, A_ub=A, b_ub=b, bounds=[x_bounds, y_bounds])

print("Optimal solution:", res.x)
print("Optimal value:", -res.fun)

OutPut:
Optimal solution: [2. 0.]
Optimal value: 2.0

7).
Max. Z = 4x + y + 3z + 5w
Subject to,
4x + 6y - 5z - 4w >= 20
-3x - 2y + 4z + w <= 10
-8x 􀀀 3y + 3z + 2w <= 20
x >= 0; y >= 0; z >= 0;w >= 0

Ans:
from scipy.optimize import linprog

c = [-4, -1, -3, -5]
A = [[-4, -6, 5, 4], [3, 2, -4, -1], [8, 3, -3, -2]]
b = [-20, 10, 20]
x_bounds = (0, None)
y_bounds = (0, None)
z_bounds = (0, None)
w_bounds = (0, None)
res = linprog(c, A_ub=A, b_ub=b, bounds=[x_bounds, y_bounds, z_bounds, w_bounds])

print("Optimal solution:", res.x)
print("Optimal value:", -res.fun)

OutPut:
Optimal solution: None

	-----------------------------------------------------------------
				Practical 11 & 12
	-----------------------------------------------------------------

Q.Solve the transportation problem with the cost coecient requirement and supplies as given in the following table

1).
Ans:
from pulp import *

factories = ["F1", "F2", "F3"]
warehouses = ["W1", "W2", "W3", "W4"]
supply = {"F1": 7, "F2": 9, "F3": 18}
demand = {"W1": 5, "W2": 8, "W3": 7, "W4": 14}

costs = {
    "F1": {"W1": 19, "W2": 30, "W3": 50, "W4": 10},
    "F2": {"W1": 70, "W2": 30, "W3": 40, "W4": 60},
    "F3": {"W1": 40, "W2": 8, "W3": 70, "W4": 20}
}

prob = LpProblem("Transportation", LpMinimize)

routes = [(f, w) for f in factories for w in warehouses]
route_vars = LpVariable.dicts("Route", (factories, warehouses), lowBound=0, cat='Integer')

prob += lpSum(route_vars[f][w] * costs[f][w] for (f, w) in routes)

for f in factories:
    prob += lpSum(route_vars[f][w] for w in warehouses) == supply[f]

for w in warehouses:
    prob += lpSum(route_vars[f][w] for f in factories) == demand[w]

prob.solve()

print("Optimal transportation plan:")
for f in factories:
    for w in warehouses:
        if route_vars[f][w].varValue > 0:
            print(f"Factory {f} -> Warehouse {w}: {route_vars[f][w].varValue}")

print("Total transportation cost:", value(prob.objective))

OutPut:
Optimal transportation plan:
Factory F1 -> Warehouse W1: 5.0
Factory F1 -> Warehouse W4: 2.0
Factory F2 -> Warehouse W2: 2.0
Factory F2 -> Warehouse W3: 7.0
Factory F3 -> Warehouse W2: 6.0
Factory F3 -> Warehouse W4: 12.0
Total transportation cost: 743.0

2).
Ans:
from pulp import *

company = ["A", "B", "C", "D"]
supply = {"A": 50, "B": 70, "C": 30, "D": 50}

shop = ["I", "II", "III", "IV"]
demand = {"I": 25, "II": 35, "III": 105, "IV": 20}
costs = {"A": {"I": 4, "II": 6, "III": 8, "IV": 13},
         "B": {"I": 13, "II": 11, "III": 10, "IV": 8},
         "C": {"I": 14, "II": 4, "III": 10, "IV": 13},
         "D": {"I": 9, "II": 11, "III": 13, "IV": 8}}

prob = LpProblem("Transportation", LpMinimize)

Routes = [(w, r) for w in company for r in shop]

vars = LpVariable.dicts("Route", (company, shop), 0, None, LpInteger)

prob += lpSum([vars[w][r] * costs[w][r] for (w, r) in Routes]), "Sum_of_Costs"

for w in company:
    prob += lpSum([vars[w][r] for r in shop]) <= supply[w], "Sum_Prod_%s" % w

for r in shop:
    prob += lpSum([vars[w][r] for w in company]) >= demand[r], "Sum_Prod_%s" % r

prob.writeLP("Transportation.lp")

OutPut:

3).
from pulp import *

origins = ["A", "B", "C"]
costs = {
    "A": {"X": 8, "Y": 7, "Z": 3},
    "B": {"X": 3, "Y": 8, "Z": 9},
    "C": {"X": 11, "Y": 3, "Z": 5}
}

requirements = {"X": 50, "Y": 80, "Z": 80}
available = {"A": 60, "B": 70, "C": 80}

prob = LpProblem("Transportation", LpMinimize)

routes = [(o, d) for o in origins for d in requirements]

vars = LpVariable.dicts("Route", (origins, requirements), 0, None, LpInteger)

prob += lpSum([vars[o][d] * costs[o][d] for (o, d) in routes])

for o in origins:
    prob += lpSum([vars[o][d] for d in requirements]) <= available[o]

for d in requirements:
    prob += lpSum([vars[o][d] for o in origins]) == requirements[d]

prob.solve()

print("Optimal transportation plan:")
for o in origins:
    for d in requirements:
        print(f"From {o} to {d}: {vars[o][d].varValue}")

print("Total transportation cost:", value(prob.objective))

OutPut:
Optimal transportation plan:
From A to X: 0.0
From A to Y: 0.0
From A to Z: 60.0
From B to X: 50.0
From B to Y: 0.0
From B to Z: 20.0
From C to X: 0.0
From C to Y: 80.0
From C to Z: 0.0
Total transportation cost: 750.0

4).
from pulp import *

costs = [[3, 8, 2, 10, 3],
         [8, 7, 2, 9, 7],
         [6, 4, 2, 7, 5],
         [8, 4, 2, 3, 5],
         [9, 10, 6, 9, 10]]

machines = range(len(costs))
jobs = range(len(costs[0]))

prob = LpProblem("Assignment Problem", LpMinimize)

x = LpVariable.dicts("Assignment", (machines, jobs), 0, 1, LpBinary)

prob += lpSum(costs[m][j] * x[m][j] for m in machines for j in jobs)

for m in machines:
    prob += lpSum(x[m][j] for j in jobs) == 1

for j in jobs:
    prob += lpSum(x[m][j] for m in machines) == 1

prob.solve()

print("Minimum cost:", value(prob.objective))
print("Assignment:")
for m in machines:
    for j in jobs:
        if x[m][j].value() == 1:
            print(f"Machine {m+1} is assigned to Job {j+1}")

OutPut:
Minimum cost: 21.0
Assignment:
Machine 1 is assigned to Job 5
Machine 2 is assigned to Job 3
Machine 3 is assigned to Job 2
Machine 4 is assigned to Job 4
Machine 5 is assigned to Job 1

6).
from pulp import *

machines = ["1", "2", "3", "4", "5"]
jobs = ["A", "B", "C", "D", "E"]
profits = {
    "1": {"A": 30, "B": 37, "C": 40, "D": 28, "E": 40},
    "2": {"A": 40, "B": 24, "C": 27, "D": 21, "E": 36},
    "3": {"A": 40, "B": 32, "C": 33, "D": 30, "E": 35},
    "4": {"A": 25, "B": 38, "C": 40, "D": 36, "E": 36},
    "5": {"A": 29, "B": 32, "C": 41, "D": 34, "E": 39}
}

prob = LpProblem("Assignment", LpMaximize)

assignments = LpVariable.dicts("Assignment", (machines, jobs), cat="Binary")

prob += lpSum([profits[m][j] * assignments[m][j] for m in machines for j in jobs])

for m in machines:
    prob += lpSum([assignments[m][j] for j in jobs]) <= 1

for j in jobs:
    prob += lpSum([assignments[m][j] for m in machines]) == 1

prob.solve()

print("Optimal assignments:")
for m in machines:
    for j in jobs:
        if assignments[m][j].varValue == 1:
            print(f"Machine {m} is assigned to Job {j}")

OutPut:
Optimal assignments:
Machine 1 is assigned to Job B
Machine 2 is assigned to Job E
Machine 3 is assigned to Job A
Machine 4 is assigned to Job D
Machine 5 is assigned to Job C


		--------------------------- End ---------------------------


